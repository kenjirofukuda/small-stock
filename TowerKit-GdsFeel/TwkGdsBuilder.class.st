Class {
	#name : #TwkGdsBuilder,
	#superclass : #Object,
	#instVars : [
		'model'
	],
	#category : #'TowerKit-GdsFeel'
}

{ #category : #accessing }
TwkGdsBuilder >> autoGeneratedStructure [
	^ self library ensureCreateStrucureNamed: self autoGeneratedStructureName 
]

{ #category : #accessing }
TwkGdsBuilder >> autoGeneratedStructureName [
	^ self subclassResponsibility
]

{ #category : #constants }
TwkGdsBuilder >> layerNumberForPoint [
	^ 1
]

{ #category : #constants }
TwkGdsBuilder >> layerNumberForSegment [
	^ 2
]

{ #category : #constants }
TwkGdsBuilder >> layerNumberForSegmentText [
	^ 4
]

{ #category : #constants }
TwkGdsBuilder >> layerNumberForSplitedSegment [
	^ 4
]

{ #category : #constants }
TwkGdsBuilder >> layerNumberForText [
	^ 3
]

{ #category : #accessing }
TwkGdsBuilder >> model [
	^ model
]

{ #category : #accessing }
TwkGdsBuilder >> model: aTwkNode [
	model := aTwkNode
]

{ #category : #'as yet unclassified' }
TwkGdsBuilder >> putObjectName: aTwkObject centerAt: aCenterPoint on: aGdsStructure [
	self putObjectName: aTwkObject centerAt: aCenterPoint on: aGdsStructure angle: 0.0
]

{ #category : #'as yet unclassified' }
TwkGdsBuilder >> putObjectName: aTwkObject centerAt: aCenterPoint on: aGdsStructure angle: anAngle [
	| textAttr |
	textAttr := TwkText new.
	textAttr contents: aTwkObject name.
	textAttr basePoint: aCenterPoint.
	aGdsStructure currentItem
		angle: anAngle;
		text: textAttr contents;
		putBoxText: textAttr boundsByCenter.
]

{ #category : #utility }
TwkGdsBuilder >> rotatePoint: aPoint bySegment: aLineSegment [
	^ (aPoint rotateInModelBy: (TwkTowerKit segmentAngle: aLineSegment) degreesToRadians about: 0 @ 0)
		roundTo: TwkTowerKit epsilon
]

{ #category : #'text offset' }
TwkGdsBuilder >> slantTextAttrDo: aTwkText segment: aLineSegment [
	| seg baseOffset standOffset |
	seg := aLineSegment asStandDirection.
	baseOffset := aTwkText textHeight * 0.6.
	standOffset := (self standOffsetSignOfSegment: seg textAttr: aTwkText) * baseOffset.
	aTwkText offset: (self rotatePoint: standOffset bySegment: seg)
]

{ #category : #'text offset' }
TwkGdsBuilder >> standOffsetSignOfSegment: aLineSegment textAttr: aTwkText [
	| scaledPoints |
	(aTwkText valueOfProperty: #slice ifAbsent: [  ])
		ifNotNil: [ :slice | 
			(slice planeSideCross crossValues includes: #diamond)
				ifTrue: [ 
					"â—‡: cross"
					scaledPoints := (aLineSegment midPointScaled: 0.8) controlPoints.
					(scaledPoints allSatisfy: [ :each | each sign = (1 @ 1) ])
						ifTrue: [ ^ 0 @ -1 ].
					(scaledPoints allSatisfy: [ :each | each sign = (-1 @ 1) ])
						ifTrue: [ ^ 0 @ -1 ].
					(scaledPoints allSatisfy: [ :each | each sign = (-1 @ -1) ])
						ifTrue: [ ^ 0 @ 1 ].
					(scaledPoints allSatisfy: [ :each | each sign = (1 @ -1) ])
						ifTrue: [ ^ 0 @ 1 ] ] ].	

	"X: cross"
	aLineSegment end sign = (1 @ 1)
		ifTrue: [ ^ 0 @ 1 ].
	aLineSegment end sign = (-1 @ 1)
		ifTrue: [ ^ 0 @ -1 ].
	aLineSegment start sign = (-1 @ -1)
		ifTrue: [ ^ 0 @ -1 ].
	aLineSegment start sign = (1 @ -1)
		ifTrue: [ ^ 0 @ 1 ].	"else"
	^ 0 @ 0
]

{ #category : #utility }
TwkGdsBuilder >> structureDo: aBlock [
	self autoGeneratedStructure
		ifNotNil: [ :structure | 
			self assert: GdsStation default library notNil.
			GdsStation default library station ifNil: [ GdsStation default library station: GdsStation default ].
			GdsStation default structure: structure.			
			aBlock value: structure ]
]

{ #category : #accessing }
TwkGdsBuilder >> userStructure [
	^ self subclassResponsibility
]
