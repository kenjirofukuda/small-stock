Class {
	#name : #TwkFaceGdsBuilder,
	#superclass : #TwkGdsBuilder,
	#category : #'TowerKit-GdsFeel'
}

{ #category : #accessing }
TwkFaceGdsBuilder >> autoGeneratedStructureName [
	^ (Array with: self model parent name with: self model directionString with: 'AG') joinUsing: '_' 
]

{ #category : #building }
TwkFaceGdsBuilder >> build [
	self structureDo: [ :s |
		s removeAllElements.
		self createSlopePointsOn: s.
		self createSlopsOn: s.
		self createSpanCrossesOn: s.
		self createPassiveSegmentsOn: s.		
		self createFacePointsOn: s.
	].

	self createUserStructure.
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createFacePointsOn: s [
	s currentItem layerNumber: self layerNumberForPoint.
	s currentItem point.
	self model facePoints
		do: [ :p | 			
			s currentItem putPoint: p ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createNodeNumbersOn: aGdsStructure segments: aStanNodeCollection hasMargin: aUseMargin [
	| textAttr |
	textAttr := TwkText new.
	textAttr textHeight: (self textHeightOfStructure: aGdsStructure).
	textAttr useMargin: aUseMargin.
	textAttr vertical: self model parent isPost.
	aStanNodeCollection
		do: [ :stanNode | 
			textAttr basePoint: (self facePointFromNode: stanNode).
			textAttr contents: stanNode name .
			aGdsStructure currentItem
				ifNotNil: [ :item | 
					item layerNumber: self layerNumberForText.
					item angle: 0.0.
					item text: textAttr contents.
					item putBoxText: textAttr boundsByCenter ] ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createPassiveSegmentsOn: s [
	s currentItem layerNumber: self layerNumberForSegment.
	self model planeMemberSegments do: [ :seg | 
		s currentItem putPathFrom: seg start to: seg end ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSectionRoundInsertPointsOn: s [
	s currentItem layerNumber: self layerNumberForPoint.
	s currentItem point.
	self model facePoints
		do: [ :p | 			
			s currentItem putPoint: p ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSegmentNumbers: aStanSegmentCollection hasMargin: aHasMargine [
	self
		structureDo: [ :s | 
			self
				createSegmentNumbersOn: s 
				segments: aStanSegmentCollection 
				hasMargin: aHasMargine ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSegmentNumbersOn: aGdsStructure segments: aStanSegmentCollection hasMargin: aHasMargin [
	| textAttr |
	textAttr := TwkText new.
	textAttr textHeight: (self textHeightOfStructure: aGdsStructure).
	textAttr useMargin: aHasMargin.
	textAttr marginRatio: 0.5.
	textAttr vertical: self model parent isPost.
	aStanSegmentCollection
		do: [ :stanSegment | 
			|   segment2d |
			segment2d := LineSegment 
				from: (self facePointFromNode: stanSegment from) 
				to: (self facePointFromNode: stanSegment to).
			textAttr basePoint: segment2d midPoint.
			textAttr contents: stanSegment name.
			aHasMargin "Face"
				ifFalse: [ 
					self slantTextAttrDo: textAttr segment: segment2d
					 ].
			
			aGdsStructure currentItem
				ifNotNil: [ :item | 
					item layerNumber: self layerNumberForSegmentText.
					item angle: (TwkTowerKit segmentAngle: segment2d).
					item text: textAttr contents.
					item putBoxText: textAttr boundsByCenter ] ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSegmentOn: aGdsStructure segments: aStanSegmentCollection [
	aStanSegmentCollection
		do: [ :stanSegment | 
			|   segment2d |
			segment2d := LineSegment 
				from: (self facePointFromNode: stanSegment from) 
				to: (self facePointFromNode: stanSegment to).
			aGdsStructure currentItem
				ifNotNil: [ :item | 
					item layerNumber: self layerNumberForSegment.
					item putSegment: segment2d ] ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSlopePointsOn: s [
	| mirrorSelector splitedPoints |
	mirrorSelector := self model isHorizontalStack
		ifTrue: [ #horizontalMirrored ]
		ifFalse: [ #verticalMirrored ].
	s currentItem layerNumber: self layerNumberForPoint.
	s currentItem point.
	splitedPoints := self model splitedHalfPoints.
	"self isHorizontalStack 
		ifFalse: [ splitedPoints := splitedPoints reversed ]."
	splitedPoints
		do: [ :p | 
			s currentItem putPoint: p.
			s currentItem putPoint: (p perform: mirrorSelector) ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSlopsOn: s [
	s currentItem layerNumber: self layerNumberForSegment.
	(self model minusSlopeSegments, self model plusSlopeSegments) 
		do: [ :seg | 
			s currentItem putPathFrom: seg start to: seg end.
			s elements last setProperty: #'towerkit.kind' toValue: 'slope' ].
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createSpanCrossesOn: s [
	| segs |
	segs := self model stanSegmentsForPanel.
	self createSegmentOn: s segments: segs 
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> createUserStructure [
	self userStructureDo: [ :s |
		s elements ifEmpty: [ 
			GdsStation default structure: s.
			s currentItem sref.
			s currentItem structureName: self autoGeneratedStructureName.
			s currentItem ce: 0 @ 0.
			s currentItem put.
			"s forceSave	"		
			 ]
		 ]
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> facePointFromNode: aTwkStanNode [
	self isBeamAndBack
		ifTrue: [ 
			^ self model facePointFromNode: aTwkStanNode index2d: #(1 3 1) ].
	^ self model facePointFromNode: aTwkStanNode
]

{ #category : #testing }
TwkFaceGdsBuilder >> isBeamAndBack [
	^ self model parent isBeam and: [ self model direction = #back ]
]

{ #category : #accessing }
TwkFaceGdsBuilder >> library [
	^ self model compositBrick gdsBuilder library 
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> putNodeNumbersForFacePoint: aTwkStanNodeCollection [
	self  
		structureDo: [ :s | 
			aTwkStanNodeCollection
				do: [ :node | 
					| textAttr |
					textAttr := TwkText new.
					textAttr textHeight: self model parent gdsBuilder textHeight.
					textAttr contents: node name.
					textAttr basePoint: (self facePointFromNode: node).
					s currentItem 
						angle: 0.0;
						text: textAttr contents;
						putBoxText: textAttr boundsByCenter ].
			"s forceSave" ]
]

{ #category : #'text offset' }
TwkFaceGdsBuilder >> standOffsetSignOfSegment: aLineSegment textAttr: aTwkText [
	"S cross"
	(aLineSegment controlPoints allSatisfy: [ :p | p x abs > 10.0 ])
		ifTrue: [
			  ^ 0 @ 1 ].

	"W cross"	
	((aLineSegment end x closeTo: 0.0) and: [ aLineSegment start y < aLineSegment end y ])
		ifTrue: [
			(aLineSegment start x < 0.0)
				ifTrue: [ ^ 0 @ -1 ].
			(aLineSegment start x > 0.0)
				ifTrue: [ ^ 0 @ 1 ] ].
	^ super standOffsetSignOfSegment: aLineSegment textAttr: aTwkText

]

{ #category : #accessing }
TwkFaceGdsBuilder >> structureName [
	^ (Array with: self model parent name with: self model directionString) joinUsing: '_' 
]

{ #category : #accessing }
TwkFaceGdsBuilder >> textHeight [
	^ self model parent gdsBuilder textHeight.

]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> textHeightOfStructure: aGdsStructure [
	^ self model parent gdsBuilder textHeightOfStructure: aGdsStructure.

]

{ #category : #accessing }
TwkFaceGdsBuilder >> userStructure [
	^ self library ensureCreateStrucureNamed: self structureName  
]

{ #category : #'as yet unclassified' }
TwkFaceGdsBuilder >> userStructureDo: aBlock [
	self userStructure
		ifNotNil: [ :structure | aBlock value: structure ] 
]
