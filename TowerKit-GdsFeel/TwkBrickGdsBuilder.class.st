Class {
	#name : #TwkBrickGdsBuilder,
	#superclass : #TwkGdsBuilder,
	#category : #'TowerKit-GdsFeel'
}

{ #category : #accessing }
TwkBrickGdsBuilder >> autoGeneratedStructureName [
	^ (Array with: self model name with: 'AG') joinUsing: '_' 
]

{ #category : #accessing }
TwkBrickGdsBuilder >> beamStep [
	^ 3324
]

{ #category : #building }
TwkBrickGdsBuilder >> build [
	(Array
		streamContents: [ :s | 
			s nextPut: [ self model faces do: [ :face | face gdsBuilder build ] ].
			s nextPut: [ self createSlices ].
			s nextPut: [ self createNodeNumbers ].
			s nextPut: [ self createSegmentNumbers ].
			s nextPut: [ self createLayout ] ])
		do: [ :step | step value ]
		displayingProgress: 'Building ...'
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> createFacesLayout [
	| sizeSelector refOrigin stepOffset maxSize |
	sizeSelector := self model isHorizontalStack
		ifTrue: [ #height ]
		ifFalse: [ #width ].
	"refOrigin := self model isHorizontalStack
		ifTrue: [ 8922 @ 27200 ]
		ifFalse: [ 6810 @ 7150 ]."
	refOrigin := 0 @ 0.
		
	maxSize := (self model faces collect: [ :face | 
		face gdsBuilder autoGeneratedStructure dataExtentForElements perform: sizeSelector ])
		max.
	"stepOffset := Point x: (maxSize * 2.5 roundTo: 100) y: 0."
	stepOffset := (self postStep @ 0).
	self 
		structureDo: [ :s | 
			| displayFaces |
			s removeAllElements.
			self model isHorizontalStack
				ifTrue: [ 
					"stepOffset := stepOffset rightRotatedInModel ".
					stepOffset := 0 @ (self beamStep abs negated).].
			displayFaces := self model faces.
			"self isHorizontalStack
				ifTrue: [ displayFaces := displayFaces reversed ]."
			displayFaces
				do: [ :face | 
					s currentItem sref.
					s currentItem structureName: face autoGeneratedStructureName.
					s currentItem ce: refOrigin.
					s currentItem put.
					refOrigin := refOrigin + stepOffset ].
			"s forceSave" ].
	self model setProperty: #refOrigin toValue: refOrigin.
	self model setProperty: #stepOffset toValue: stepOffset.

]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> createLayout [
	self  createFacesLayout.
	self  createSlicesLayout.
]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbers [
	"Face side"
	self createNodeNumbersForSlope.
	self createNodeNumbersForFace.
	self createNodeNumbersForFaceRoundInsert.
	
	"Section side"
	self createNodeNumbersForSectionCenter.
	self createNodeNumbersForSectionRound.
	self createNodeNumbersForSectionRoundInsert.
	self createNodeNumbersForSectionFace.	
]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForFace [
	self createNodeNumbersForFaceFromMap: self model stanNodeNumbersMapForFacePoint.

]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForFaceFromMap: aDirectionToNodesMap [
	aDirectionToNodesMap
		keysAndValuesDo: [ :direction :thisNodes | 
			(self model faceAt: direction) 
				gdsBuilder putNodeNumbersForFacePoint: thisNodes ]
]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForFaceRoundInsert [
	self createNodeNumbersForFaceFromMap: self model stanNodeNumbersMapForFaceRoundInsert.

]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForSectionCenter [
	self putNodeNumbers: self model stanNodesForSectionCenter.

]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForSectionFace [
	| spanToNodeMap |
	spanToNodeMap := self model spanToSectionFaceNodeMap.
	spanToNodeMap
		keysAndValuesDo: [ :span :nodes | 
			| strucName |
			strucName := self structureNameForSlice: span.
			(self ensureCreateStrucureNamed: strucName)
				ifNotNil: [ :s | 
					GdsStation default structure: s.
					nodes
						do: [ :node | 
							self
								putNodeNumber: node
								on: s
								textAttrDo: [ :attr | 
									self roundAttr: attr hMarginRatio: 0.8 vMarginRatio: 0.8 ] ] ] ]
]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForSectionRound [
	self putNodeNumbers: self model stanNodesForSlope.

]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForSectionRoundInsert [
	self putNodeNumbers: self model stanNodesForSectionRoundInsert.

]

{ #category : #'node number' }
TwkBrickGdsBuilder >> createNodeNumbersForSlope [
	| legs |
	legs := self model stanNodesArrayByLegs.
	self model directionToLegIndexsArray
		do: [ :inf | 
			(self model faceAt: inf first)
				ifNotNil: [ :face | 
					face gdsBuilder
						structureDo: [ :s | 
							"self haltIf: [ self model isBeam  and: [inf first = #back] ]."	
							face  
								gdsBuilder createNodeNumbersOn: s 
								segments: ((legs at: inf second) , (legs at: inf third)) 
								hasMargin: true ] ] ]
]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> createSegmentNumbers [
	"Slope"

	self createSegmentNumbersForSlope.	"Section Round"
	#(#SectionRound #SectionSlant #SectionHorizontal #SectionVertical)
		do: [ :kind | self createSegmentNumbersBySelector: (#stanSegmentsFor , kind) asSymbol ].	"Face"
	self createSegmentNumbersForPanel.
	
]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> createSegmentNumbersBySelector: aGetSegmentsSelector [
	(self model spanToStanSegmentsMap: (self model perform: aGetSegmentsSelector))
		keysAndValuesDo: [ :slice :sliceSegments | 
			(self ensureCreateStrucureNamed: (self structureNameForSlice: slice))
				ifNotNil: [ :s | 
					self
						putSegmentNumbers: sliceSegments
						slice: slice
						on: s
						textAttrDo:
							[ :textAttr :segment2d | self textAttrDo: textAttr segment: segment2d selector: aGetSegmentsSelector ] ] ]
]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> createSegmentNumbersForPanel [
	| segs |
	segs := self model stanSegmentsForPanel.
	self model faces
		do: [ :face | 
			| stanSegs |
			stanSegs := segs select: [ :each | each parent = face ].
			face gdsBuilder createSegmentNumbers: stanSegs hasMargin: false ]
]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> createSegmentNumbersForSlope [
	| segs |
	segs := self model stanSegmentsForSlope.
	self model directionToLegIndexsArray
		do: [ :inf | 
			| faceSegments  |
			faceSegments := segs select: [ :seg | seg hasLegIndexes: inf allButFirst ].
			(self model faceAt: inf first)
				ifNotNil: [ :face | 
					face gdsBuilder 
						structureDo: [ :s | 
							"self haltIf: [ self model isBeam  and: [inf first = #back] ]."	
							face 
								gdsBuilder createSegmentNumbersOn: s 
								segments: faceSegments 
								hasMargin: true	 ] ] ]
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> createSlices [
	| sucessedNames |
	sucessedNames := OrderedCollection new.
	((self model realMaterialSpansOrdered) reject: [ :span | span value closeTo: 0.0 ])
		do: [ :span | 
			(self createSlices: span) 
				ifNotNil: [ :strucName | sucessedNames add: strucName ] ].
	self model setProperty: #sliceStructureNames toValue: sucessedNames
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> createSlices: aTwkStackItem [
	| strucName roundSegs crossSegs crossPoints |
	strucName := self structureNameForSlice: aTwkStackItem.
	roundSegs := aTwkStackItem planeSideCross splitedRoundSegments.
	crossSegs := aTwkStackItem planeSideCross splitedCrossSegments.
	crossPoints := OrderedCollection new.
	(self ensureCreateStrucureNamed: strucName)
		ifNotNil: [ :s | 
			GdsStation default structure: s.
			s removeAllElements.
			s setProperty: #stackItem toValue: aTwkStackItem.
			s currentItem layerNumber: self layerNumberForSegment.
			s currentItem path.
			roundSegs
				do: [ :seg1 | 
					s currentItem putSegment: seg1.
					s elements last setProperty: #'towerkit.kind' toValue: 'round' ].
			aTwkStackItem isDummyCross 
				ifFalse: [	
					crossSegs
						do: [ :seg2 | 
							s currentItem putSegment: seg2.
							crossPoints add: seg2 start.
							crossPoints add: seg2 end.
							s elements last setProperty: #'towerkit.kind' toValue: 'cross' ]].
			s currentItem point.
			s currentItem layerNumber: self layerNumberForPoint.
			aTwkStackItem planeSideCross indexedPoints
				ifNotEmpty: [ :indexedPoints | 
					(indexedPoints copyFrom: 1 to: 4)
						do: [ :pt | 
							s currentItem putPoint: pt.
							s elements last setProperty: #'towerkit.kind' toValue: 'round' ] ].
					
			aTwkStackItem planeSideCross insertPoints
				do: [ :pt | 
					s currentItem putPoint: pt.
					s elements last setProperty: #'towerkit.kind' toValue: 'round'  ].
										
			crossPoints addAll: aTwkStackItem planeSideCross crossPoints.
			crossPoints := crossPoints asSet asArray.
			crossPoints do: [ :pt |						
					s currentItem putPoint: pt.
					s elements last setProperty: #'towerkit.kind' toValue: 'cross' ] .
			"s forceSave".
			^ strucName ].
	^ nil
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> createSlicesLayout [
	| successNames refOrigin elements |
	successNames := self model valueOfProperty: #sliceStructureNames ifAbsent: [ ^ self ].
	refOrigin := self model valueOfProperty: #refOrigin ifAbsent: [ ^ self ].
	elements := OrderedCollection new.
	"self setProperty: #endMarker toValue: 0."
	self
		structureDo: [ :s | 
			| refStruct stackItem spacing placeOrigin |
			spacing := self model isBeam
				ifTrue: [ 2124 ]
				ifFalse: [ (self pitchVolumeOfStructure: s names: successNames) * 2 ].

			successNames
				doWithIndex: [ :strucName :index | 
					refStruct := s library structureNamed: strucName.
					stackItem := refStruct valueOfProperty: #stackItem ifAbsent: [  ].
					placeOrigin := self
						makeOriginItem: stackItem
						index: index
						spacing: spacing
						refOrigin: refOrigin.
					s currentItem sref.
					s currentItem structureName: strucName.
					s currentItem ce: placeOrigin.
					s currentItem put.
					elements add: s elements last.
					 ].
			"(self indexesOfConflictElements: elements) 
				ifNotEmptyDo: [ :indexes | 
					indexes do: [ :pair | 
						| i e sname |
						i := pair last.
						e := elements at: i.
						sname := e structureName.
							
						placeOrigin := ((slideOffset * 2) asPoint * self model layoutOriginMask) + e xy.
						  	
						s currentItem get: e.
						s currentItem wipe.	
						s currentItem sref.
						s currentItem structureName: sname.
						s currentItem ce: placeOrigin.
						s currentItem put.													
						] ] ."
			successNames
				doWithIndex: [ :strucName :index | 
					(s library structureNamed: strucName) removeProperty: #stackItem				
				]
			].
	self model removeProperty: #sliceStructureNames.
	self model removeProperty: #refOrigin
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> ensureCreateAllStructures [
	^ Array
		streamContents: [ :s | 
			self model allBricks
				do: [ :each | 
					s nextPutAll: each gdsBuilder ensureCreateFaceStructures.
					s nextPutAll: each gdsBuilder ensureCreateUserFaceStructures ] ]
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> ensureCreateFaceStructures [
	^ Array streamContents: [ :s |
		self model faces do: [ :face |
			s nextPut: face gdsBuilder autoGeneratedStructure ] ]
]

{ #category : #'structure control' }
TwkBrickGdsBuilder >> ensureCreateStrucureNamed: aStructureName [
	^ self library ensureCreateStrucureNamed: aStructureName  
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> indexesOfConflictElements: aGdsElementCollection [
	| indexes a b test |
	indexes := Array
		streamContents: [ :s | 
			(1 to: aGdsElementCollection size)
				do: [ :i | 
					(1 to: aGdsElementCollection size)
						do: [ :j | 
							a :=  (aGdsElementCollection at: i).
							b :=  (aGdsElementCollection at: j).
							a == b
								ifFalse: [
									test := a dataBounds intersects: b dataBounds.
									test
										ifTrue: [ s nextPut: (Array with: i with: j) sorted ] ] ] ] ].
	indexes := indexes asSet asArray.
	^ indexes
]

{ #category : #accessing }
TwkBrickGdsBuilder >> library [
	^ self model parent gdsBuilder library
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> makeOriginItem: stackItem index: index spacing: spacing refOrigin: refOrigin [
	^ self makeOriginItem: stackItem index: index  spacing:  spacing refOrigin: refOrigin scale: 1.0 
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> makeOriginItem: stackItem index: index spacing: spacing refOrigin: refOrigin scale: scale [
	| placeOrigin step   newValue |
	step := (stackItem value / 2) + spacing. 	
	"maxValue := self valueOfProperty: #endMarker."
	self model isPost
		ifTrue: [ 
			| newX  mod |
			mod := (index - 1) \\ 2.
			newX := refOrigin x + (scale * (step * mod)) .
			mod = 0 ifTrue: [ newX := newX + (stackItem value / 2) ].
			"maxValue := maxValue max: newX + (stackItem value / 2). "
			placeOrigin := newX @ stackItem sectionHeight.
			newValue := newX
			 ]
		ifFalse: [ 
			| newY  mod |
			mod := (index - 1) \\ 3.
			step := mod = 0 
				ifTrue: [ (stackItem value / 2) + spacing ]
				ifFalse: [ stackItem value + spacing ].			
			newY := refOrigin y + (scale * (step * mod)) negated.
			placeOrigin := stackItem sectionHeight @ newY .
			newValue := newY].
	"maxValue := maxValue max: newValue + (stackItem value / 2)." 
	"self setProperty: #endMarker toValue: maxValue."
	^ placeOrigin
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> pitchVolumeOfStructure: s names: successNames [
	| pitchVolume extentArray |
	successNames ifEmpty: [ ^ 0 ].		
	extentArray := successNames collect: [ :each | (s library structureNamed: each) dataExtentForElements ].
	pitchVolume := self model isPost
		ifTrue: [ (extentArray collect: [ :each | each width ]) max ]
		ifFalse: [ (extentArray collect: [ :each | each height ]) max ].
	^ pitchVolume
]

{ #category : #accessing }
TwkBrickGdsBuilder >> postStep [
	^ 8350
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> putNodeNumber: foundNode on: aGdsStructure [
	self putNodeNumber: foundNode on: aGdsStructure textAttrDo: [ :attr | ]
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> putNodeNumber: foundNode on: aGdsStructure textAttrDo: aTextAttrBlock [
	|   textAttr |
	textAttr := TwkText new.
	textAttr basePoint: (self model slicePointFromNode: foundNode).
	textAttr textHeight: self textHeight.
	textAttr contents: foundNode name.
	aTextAttrBlock value: textAttr.
	aGdsStructure currentItem
		angle: 0.0;
		text: textAttr contents;
		putBoxText: textAttr boundsByCenter
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> putNodeNumbers: aTwkStanNodeCollection [
	self model realMaterialSpansOrdered
		do: [ :slice | 
			(self ensureCreateStrucureNamed: (self structureNameForSlice: slice))
				ifNotNil: [ :s | 
					self 
						putNodeNumbers: aTwkStanNodeCollection 
						slice: slice 
						on: s ] ]
]

{ #category : #'primitive text' }
TwkBrickGdsBuilder >> putNodeNumbers: aStanNodes slice: slice on: aGdsStructure [
	GdsStation default structure: aGdsStructure.
	aGdsStructure currentItem layerNumber: self layerNumberForText.
	(self model findRoundNodesForSlice: slice inStanNodes: aStanNodes) 	
		ifNotEmpty: [ :foundNodes | 
			foundNodes do: [ :foundNode | 
				self 
					putNodeNumber: foundNode 
					on: aGdsStructure 
					textAttrDo: [ :attr |
						| hMargin |
						hMargin := self model isBeam ifTrue: [ 0.5 ] ifFalse: [ 0.8 ]. 
						self roundAttr: attr hMarginRatio: hMargin vMarginRatio: 0.8 ] ] ]
		ifEmpty: [ self traceCr: ('detect fail: <1p>' expandMacrosWith: slice) ].
	"^ aGdsStructure forceSave"
]

{ #category : #'primitive text' }
TwkBrickGdsBuilder >> putSegmentNumbers: aStanSegments slice: slice on: aGdsStructure [
	self putSegmentNumbers: aStanSegments slice: slice on: aGdsStructure textAttrDo: [ :attr |  ]
]

{ #category : #'primitive text' }
TwkBrickGdsBuilder >> putSegmentNumbers: aStanSegments slice: slice on: aGdsStructure textAttrDo: aTextAttrBlock [
	| textAttr |
	GdsStation default structure: aGdsStructure.
	textAttr := TwkText new.
	textAttr setProperty: #slice toValue: slice. 
	textAttr textHeight: (self textHeightOfStructure: self model frontFace gdsBuilder autoGeneratedStructure).
	aStanSegments
		do: [ :stanSegment | 
			| segment2d |
			segment2d := slice point2dSegment: stanSegment.
			textAttr contents: stanSegment name.
			textAttr basePoint: segment2d midPoint.
			textAttr setProperty: #segment3d toValue: stanSegment. 
			aTextAttrBlock value: textAttr value: segment2d.
			aGdsStructure currentItem
				ifNotNil: [ :item | 
					item layerNumber: self layerNumberForSegmentText.
					item text: textAttr contents.
					item angle: (TwkTowerKit segmentAngle: segment2d).
					item putBoxText: textAttr boundsByCenter ] ]
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> roundAttr: aTwkText hMarginRatio: hMarginRatio vMarginRatio: vMarginRatio [
	| xOffset yOffset |
	xOffset := 0.
	yOffset := 0.
	aTwkText basePoint x > 0.0
		ifTrue: [ xOffset := aTwkText textWidth * hMarginRatio ].
	aTwkText basePoint x < 0.0
		ifTrue: [ xOffset := (aTwkText textWidth * hMarginRatio) negated ].
	aTwkText basePoint y > 0.0
		ifTrue: [ yOffset := aTwkText textHeight * vMarginRatio ].
	aTwkText basePoint y < 0.0
		ifTrue: [ yOffset := (aTwkText textHeight * vMarginRatio) negated ].
	aTwkText offset: xOffset @ yOffset
	
]

{ #category : #'text offset' }
TwkBrickGdsBuilder >> roundSignOfSegment: aLineSegment [
	aLineSegment isHorizontal
		ifTrue: [
			(aLineSegment controlPoints allSatisfy: [ :p | p y > 0.0 ])
				ifTrue: [ ^ 0 @ 1 ].
			(aLineSegment controlPoints allSatisfy: [ :p | p y < 0.0 ])
				ifTrue: [ ^ 0 @ -1 ] ].

	aLineSegment isVertical
		ifTrue: [
			(aLineSegment controlPoints allSatisfy: [ :p | p x > 0.0 ])
				ifTrue: [ ^ 1 @ 0 ].
			(aLineSegment controlPoints allSatisfy: [ :p | p x < 0.0 ])
				ifTrue: [ ^ -1 @ 0 ] ].
	^ 0 @ 0
]

{ #category : #'text offset' }
TwkBrickGdsBuilder >> sectionRoundTextAttrDo: aTwkText segment: aLineSegment [
	| offset offset2 signPoint moreMargin slideSign slide slideOffset |
	"self haltIf: [ { '113' . '114' . '117' . '118' } includes: aTwkText contents  ]."
	offset := aTwkText textHeight * 0.6.
	offset2 := aTwkText textHeight.
	signPoint := self roundSignOfSegment: aLineSegment.
	slide := 0.
	slideSign := 0 @ 0.
	slideOffset := 0 @ 0.
	aTwkText textWidth * 0.8 > aLineSegment length
		ifTrue: [ 
			(aTwkText valueOfProperty: #slice ifAbsent: [  ])
				ifNotNil: [ :slice | 
					slice planeSideCross splitedRoundSegments size = 4
						ifTrue: [ 
							slide := (aTwkText textWidth - aLineSegment length) * 0.5.
							signPoint = (0 @ 1)
								ifTrue: [ slideSign := 1 @ 0 ].
							signPoint = (0 @ -1)
								ifTrue: [ slideSign := -1 @ 0 ].
							signPoint = (1 @ 0)
								ifTrue: [ slideSign := 0 @ -1 ].
							signPoint = (-1 @ 0)
								ifTrue: [ slideSign := 0 @ 1 ].
							slideOffset := slideSign * slide asPoint ] ] ].
	moreMargin := false.
	aTwkText textWidth > aLineSegment length
		ifTrue: [ 
			(signPoint = (0 @ 1) and: [ aLineSegment midPoint x > 0 ])
				ifTrue: [ moreMargin := true ].
			(signPoint = (0 @ -1) and: [ aLineSegment midPoint x < 0 ])
				ifTrue: [ moreMargin := true ].
			(signPoint = (1 @ 0) and: [ aLineSegment midPoint y < 0 ])
				ifTrue: [ moreMargin := true ].
			(signPoint = (-1 @ 0) and: [ aLineSegment midPoint y > 0 ])
				ifTrue: [ moreMargin := true ] ].
	signPoint = (0 @ 0)
		ifFalse: [ 
			"self haltIf: [ slideOffset ~= (0 @ 0) ]."
			aTwkText
				offset:
					signPoint
						*
							(moreMargin
								ifTrue: [ offset + offset2 ]
								ifFalse: [ offset ]) asPoint + slideOffset ]
]

{ #category : #'text offset' }
TwkBrickGdsBuilder >> sectionSlantTextAttrDo: aTwkText segment: aLineSegment [
	self slantTextAttrDo: aTwkText segment: aLineSegment.
	(aTwkText valueOfProperty: #slice ifAbsent: [  ])
		ifNotNil: [ 
			aLineSegment length * 0.7 < aTwkText textWidth
				ifTrue: [ 
					| moreOffset standOffset |
					moreOffset := (aLineSegment length * 1.5) @ 0.
					standOffset := (self standOffsetSignOfSegment: aLineSegment asStandDirection textAttr: aTwkText) transposed * moreOffset.
					aTwkText offset: aTwkText offset + (self rotatePoint: standOffset bySegment: aLineSegment) ] ]
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> structureNameForSlice: aTwkStackItem [
	^ (Array
		with: self model name
		with: 'SLICE'
		with: aTwkStackItem index
		with: 'AG') joinUsing: '_'.

]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> textAttrBlockForSelector: aSelector [
	^ [ :textAttr |
		 ]
]

{ #category : #'segment number' }
TwkBrickGdsBuilder >> textAttrDo: aTwkText segment: aLineSegment selector: aSelecter [
	aSelecter = #stanSegmentsForSectionRound
		ifTrue: [
			^ self sectionRoundTextAttrDo: aTwkText segment: aLineSegment ].
	aSelecter = #stanSegmentsForSectionSlant
		ifTrue: [
			^ self sectionSlantTextAttrDo: aTwkText segment: aLineSegment ]
		
		
]

{ #category : #accessing }
TwkBrickGdsBuilder >> textHeight [
	^ self textHeightOfStructure: self autoGeneratedStructure
]

{ #category : #'as yet unclassified' }
TwkBrickGdsBuilder >> textHeightOfStructure: aGdsStructure [
	^ (130 * 2.5)
	
	"(aGdsStructure dataExtentForElements perform: self model longSideSelectorForRectangle) / 100."
]

{ #category : #accessing }
TwkBrickGdsBuilder >> userStructure [
	^ self library ensureCreateStrucureNamed: self structureName  
]
